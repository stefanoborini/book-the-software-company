---
nav_order: 10
---
# 10 To be reorganised

# Notes to expand

# The phases of development and needs of developers
- train team on our internal tools

# On projects

- throw software at a problem instead of a person.
- too many new tools at once.
- death by a thousands papercuts.


# On process
# On management

# On bug reporting and issue tracking

# To be organised 
- big concepts need a high level picture. No space to see it or poor tools to represent them.


# Other
- Excessive bickering over technicalities.
- disorganized, complex workflow, limited by the rate of review to get features into the main branch.
- Development model makes it complex to keep the code forward, New branches must depend on still not merged branches, meaning that often we end up with conflicts.
- unclear dependencies of the various stages of the sprint.
- hard to know the progress and the remaining work to be done for the specific
  milestone. GitHub tracker is too primitive.
- Technologies that we use are overdesigned or redundant, no training given, huge money sinks because they don't behave like expected.
- Prioritization and scheduling is pretty much left to random. PM should prioritize and assign issues, remind of the status.
- Excessive use of github issues as a "notebook" introduces a lot of notification noise. A developer has a development track. We should not keep creating issues just for us as reminders. While I understand that the goal is to keep PR small, I fear it decreases understandability instead of increasing it.
- As above, the fact that these issues are constantly added to the milestones means that it's pretty much impossible to know how far we are from reaching the goal.
- bad management of the issue tracker. keep pushing non-milestone tasks from milestone to milestone, instead of leaving them for slack time after the release. The issue list for a milestone should contain what it's expected from the customer for that iteration, that is, the goals (user story), plus the individual tasks on how to achieve that. This way we can know how far we are from customer completion.
- members enter and exit the team on-demand without any minimal planning/expected need.
- solving big problems without addressing user-centric fundamental (e.g. installation)

